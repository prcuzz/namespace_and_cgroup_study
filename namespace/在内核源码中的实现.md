# 总述

先找到namespace在task_struct中的结构，

```c
// include/linux/sched.h
struct task_struct {
......
/* namespaces */
struct nsproxy *nsproxy;
......
}
```

以及nsproxy的定义，

```c
// include/linux/nsproxy.h
/*
 * A structure to contain pointers to all per-process
 * namespaces - fs (mount), uts, network, sysvipc, etc.
 *
 * The pid namespace is an exception -- it's accessed using
 * task_active_pid_ns.  The pid namespace here is the
 * namespace that children will use.
 *
 * 'count' is the number of tasks holding a reference.
 * The count for each namespace, then, will be the number
 * of nsproxies pointing to it, not the number of tasks.
 *
 * The nsproxy is shared by tasks which share all namespaces.
 * As soon as a single namespace is cloned or unshared, the
 * nsproxy is copied.
 */
struct nsproxy {
	atomic_t count;
	struct uts_namespace *uts_ns;
	struct ipc_namespace *ipc_ns;
	struct mnt_namespace *mnt_ns;
	struct pid_namespace *pid_ns_for_children;
	struct net 	     *net_ns;
	struct cgroup_namespace *cgroup_ns;
};
extern struct nsproxy init_nsproxy;
```

其中 user namespace 是和其他 namespace 耦合在一起的，所以没出现在上述结构中。

task_struct，nsproxy，几种 namespace 之间的关系如下所示（这里的nsproxy应该是写错了，写成task_struct了）：

![img](https://images2018.cnblogs.com/blog/431521/201804/431521-20180413192120081-1220838717.png)

同时，nsproxy.h 中还定义了一些对 namespace 的操作，包括 copy_namespaces 等，

```c
int copy_namespaces(unsigned long flags, struct task_struct *tsk);
void exit_task_namespaces(struct task_struct *tsk);
void switch_task_namespaces(struct task_struct *tsk, struct nsproxy *new);
void free_nsproxy(struct nsproxy *ns);
int unshare_nsproxy_namespaces(unsigned long, struct nsproxy **,
 struct fs_struct *);
int __init nsproxy_cache_init(void);
```

nsproxy 有个 init_nsproxy 函数，init_nsproxy 在 task 初始化的时候会被初始化，

```c
// include/linux/init_task.h

/*
*  INIT_TASK is used to set up the first task table, touch at
* your own risk!. Base=0, limit=0x1fffff (=2MB)
*/
#define INIT_TASK(tsk)  \
{
......
 .nsproxy  = &init_nsproxy,
......
}
```

```c
// kernel/nsproxy.c

struct nsproxy init_nsproxy = {
	.count			= ATOMIC_INIT(1),
	.uts_ns			= &init_uts_ns,
#if defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)
	.ipc_ns			= &init_ipc_ns,
#endif
	.mnt_ns			= NULL,
	.pid_ns_for_children	= &init_pid_ns,
#ifdef CONFIG_NET
	.net_ns			= &init_net,
#endif
#ifdef CONFIG_CGROUPS
	.cgroup_ns		= &init_cgroup_ns,
#endif
};
```

init_nsproxy 中，对 uts, ipc, pid, net 都进行了初始化，但 mount 却没有。

看看 do_fork() 函数是如何处理一个新进程的 namespace 的：

```c
/*
*  Ok, this is the main fork-routine.
*
* It copies the process, and if successful kick-starts
* it and waits for it to finish using the VM if required.
*/
long do_fork(unsigned long clone_flags,
       unsigned long stack_start,
       unsigned long stack_size,
       int __user *parent_tidptr,
       int __user *child_tidptr)
{
 // 创建进程描述符指针
 struct task_struct *p;
 int trace = 0;
 long nr;

 /*
  * Determine whether and which event to report to ptracer.  When
  * called from kernel_thread or CLONE_UNTRACED is explicitly
  * requested, no event is reported; otherwise, report if the event
  * for the type of forking is enabled.
  */
 if (!(clone_flags & CLONE_UNTRACED)) {
   if (clone_flags & CLONE_VFORK)
     trace = PTRACE_EVENT_VFORK;
   else if ((clone_flags & CSIGNAL) != SIGCHLD)
     trace = PTRACE_EVENT_CLONE;
   else
     trace = PTRACE_EVENT_FORK;

   if (likely(!ptrace_event_enabled(current, trace)))
     trace = 0;
 }

 // 复制进程描述符，返回值是 task_struct
 p = copy_process(clone_flags, stack_start, stack_size,
      child_tidptr, NULL, trace);
 /*
  * Do this prior waking up the new thread - the thread pointer
  * might get invalid after that point, if the thread exits quickly.
  */
 if (!IS_ERR(p)) {
   struct completion vfork;
   struct pid *pid;

   trace_sched_process_fork(current, p);

   // 得到新进程描述符的 pid
   pid = get_task_pid(p, PIDTYPE_PID);
   nr = pid_vnr(pid);

   if (clone_flags & CLONE_PARENT_SETTID)
     put_user(nr, parent_tidptr);

   // 调用 vfork() 方法，完成相关的初始化工作  
   if (clone_flags & CLONE_VFORK) {
     p->vfork_done = &vfork;
     init_completion(&vfork);
     get_task_struct(p);
   }

   // 将新进程加入到调度器中，为其分配 CPU，准备执行
   wake_up_new_task(p);

   // fork() 完成，子进程开始运行，并让 ptrace 跟踪
   /* forking complete and child started to run, tell ptracer */
   if (unlikely(trace))
     ptrace_event_pid(trace, pid);

   // 如果是 vfork()，将父进程加入等待队列，等待子进程完成
   if (clone_flags & CLONE_VFORK) {
     if (!wait_for_vfork_done(p, &vfork))
       ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);
   }

   put_pid(pid);
 } else {
   nr = PTR_ERR(p);
 }
 return nr;
}
```

和 namespace 相关的内容在 copy_process() 中，这个函数将父进程信息复制给子进程，

```c
static struct task_struct *copy_process(unsigned long clone_flags,
         unsigned long stack_start,
         unsigned long stack_size,
         int __user *child_tidptr,
         struct pid *pid,
         int trace)
{
 int retval;
 // 创建进程描述符指针
 struct task_struct *p;
    
 ......
 // !!! 复制 namespace
 retval = copy_namespaces(clone_flags, p);
 ......
 }

 // ......

 // 返回新进程 p
 return p;
}
```

再看 copy_namespaces()，核心函数是 create_new_namespaces()，

```c
/*
* called from clone.  This now handles copy for nsproxy and all
* namespaces therein.
*/
int copy_namespaces(unsigned long flags, struct task_struct *tsk)
{
 // 老的 namespace 信息是从父进程中复制过来的
 struct nsproxy *old_ns = tsk->nsproxy;
 struct user_namespace *user_ns = task_cred_xxx(tsk, user_ns);
 struct nsproxy *new_ns;

 // 在5.17.11中，此处还会另外检查两个flag：CLONE_NEWCGROUP、CLONE_NEWTIME
 if (likely(!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |
           CLONE_NEWPID | CLONE_NEWNET)))) {	
   get_nsproxy(old_ns);
   return 0;
 }

 if (!ns_capable(user_ns, CAP_SYS_ADMIN))
   return -EPERM;

 /*
  * CLONE_NEWIPC must detach from the undolist: after switching
  * to a new ipc namespace, the semaphore arrays from the old
  * namespace are unreachable.  In clone parlance, CLONE_SYSVSEM
  * means share undolist with parent, so we must forbid using
  * it along with CLONE_NEWIPC.
  */
 if ((flags & (CLONE_NEWIPC | CLONE_SYSVSEM)) ==
   (CLONE_NEWIPC | CLONE_SYSVSEM)) 
   return -EINVAL;

 // 新的 namespace 信息根据 flag 做调整
 new_ns = create_new_namespaces(flags, tsk, user_ns, tsk->fs);
 if (IS_ERR(new_ns))
   return  PTR_ERR(new_ns);

 tsk->nsproxy = new_ns;
 return 0;
}
```

看 create_new_namespaces()，先给 nsproxy 结构申请了新内存，然后依次复制5个 namespace 的信息，

```c
/*
* Create new nsproxy and all of its the associated namespaces.
* Return the newly created nsproxy.  Do not attach this to the task,
* leave it to the caller to do proper locking and attach it to task.
*/
static struct nsproxy *create_new_namespaces(unsigned long flags,
 struct task_struct *tsk, struct user_namespace *user_ns,
 struct fs_struct *new_fs)
{
 struct nsproxy *new_nsp;
 int err;

// 创建新的 nsproxy
 new_nsp = create_nsproxy();
 if (!new_nsp)
   return ERR_PTR(-ENOMEM);

//创建 mnt namespace
 new_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, user_ns, new_fs);
 if (IS_ERR(new_nsp->mnt_ns)) {
   err = PTR_ERR(new_nsp->mnt_ns);
   goto out_ns;
 }
//创建 uts namespace
 new_nsp->uts_ns = copy_utsname(flags, user_ns, tsk->nsproxy->uts_ns);
 if (IS_ERR(new_nsp->uts_ns)) {
   err = PTR_ERR(new_nsp->uts_ns);
   goto out_uts;
 }
//创建 ipc namespace
 new_nsp->ipc_ns = copy_ipcs(flags, user_ns, tsk->nsproxy->ipc_ns);
 if (IS_ERR(new_nsp->ipc_ns)) {
   err = PTR_ERR(new_nsp->ipc_ns);
   goto out_ipc;
 }
//创建 pid namespace
 new_nsp->pid_ns_for_children =
   copy_pid_ns(flags, user_ns, tsk->nsproxy->pid_ns_for_children);
 if (IS_ERR(new_nsp->pid_ns_for_children)) {
   err = PTR_ERR(new_nsp->pid_ns_for_children);
   goto out_pid;
 }
//创建 network namespace
 new_nsp->net_ns = copy_net_ns(flags, user_ns, tsk->nsproxy->net_ns);
 if (IS_ERR(new_nsp->net_ns)) {
   err = PTR_ERR(new_nsp->net_ns);
   goto out_net;
 }

 return new_nsp;
// 错误处理
out_net:
 if (new_nsp->pid_ns_for_children)
   put_pid_ns(new_nsp->pid_ns_for_children);
out_pid:
 if (new_nsp->ipc_ns)
   put_ipc_ns(new_nsp->ipc_ns);
out_ipc:
 if (new_nsp->uts_ns)
   put_uts_ns(new_nsp->uts_ns);
out_uts:
 if (new_nsp->mnt_ns)
   put_mnt_ns(new_nsp->mnt_ns);
out_ns:
 kmem_cache_free(nsproxy_cachep, new_nsp);
 return ERR_PTR(err);
}
```

看 create_nsproxy()，

```c
static inline struct nsproxy *create_nsproxy(void)
{
	struct nsproxy *nsproxy;

	nsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);	// 从缓存中分配内存
	if (nsproxy)
		atomic_set(&nsproxy->count, 1);		// 如果没问题就计数+1
	return nsproxy;							// 返回这个新的指针
}
```

在 create_nsproxy() 之后，就是依次复制各个 namespace 的信息了，这些代码放到下面各个 namespace 中分析。每个 copy_xxx 的函数都有两个实现，其中一个需要开启对应的编译选项，不开启的话只会默认复制父进程的信息，且使用对应的 flag 会报错。

# UTS namespace

复制 uts_namespace 的函数 copy_utsname() 比较简单，

```c
struct uts_namespace *copy_utsname(unsigned long flags,
	struct user_namespace *user_ns, struct uts_namespace *old_ns)
{
	struct uts_namespace *new_ns;

	BUG_ON(!old_ns);
	get_uts_ns(old_ns);

	if (!(flags & CLONE_NEWUTS))	// 检查是否带有 CLONE_NEWUTS 标志，若无，则返回老的 ns
		return old_ns;

	new_ns = clone_uts_ns(user_ns, old_ns);	// user_ns 和 old_ns 的关系还没弄明白

	put_uts_ns(old_ns);
	return new_ns;
}
```

看 struct uts_namespace 的结构：

```c
struct uts_namespace {
	struct kref kref;			// 这个结构里面只有一个变量：atomic_t refcount
	struct new_utsname name;
	struct user_namespace *user_ns;
	struct ns_common ns;
};

struct new_utsname {
	char sysname[__NEW_UTS_LEN + 1];
	char nodename[__NEW_UTS_LEN + 1];	// host name
	char release[__NEW_UTS_LEN + 1];
	char version[__NEW_UTS_LEN + 1];
	char machine[__NEW_UTS_LEN + 1];
	char domainname[__NEW_UTS_LEN + 1];	// domain name
};
```

再看看在 sethostname 函数里 UTS namespace 是怎么被处理的。这个函数在 Linux man page 中是这么描述的：**sethostname**() sets the hostname to the value given in the character array *name*. The *len* argument specifies the number of bytes in *name*. (Thus, *name* does not require a terminating null byte.)，

```c
SYSCALL_DEFINE2(sethostname, char __user *, name, int, len)
{
	int errno;
	char tmp[__NEW_UTS_LEN];

	if (!ns_capable(current->nsproxy->uts_ns->user_ns, CAP_SYS_ADMIN))
		return -EPERM;

	if (len < 0 || len > __NEW_UTS_LEN)	// 检查传进来的长度参数 len 是否合法
		return -EINVAL;
	down_write(&uts_sem);				// uts_sem是信号量
	errno = -EFAULT;
	if (!copy_from_user(tmp, name, len)) {	// 把 name 从用户空间复制到内核空间
		struct new_utsname *u = utsname();	// utsname() 返回 &current->nsproxy->uts_ns->name

		memcpy(u->nodename, tmp, len);		// 把需要设置的 hostname 复制到 current->nsproxy->uts_ns->name->nodename
		memset(u->nodename + len, 0, sizeof(u->nodename) - len);	// 末尾置0作为结束
		errno = 0;
		uts_proc_notify(UTS_PROC_HOSTNAME);
	}
	up_write(&uts_sem);
	return errno;
}
```

由 current 找到关联的 nsproxy，然后找到 uts_ns，然后直接改 hostname 就行了，大部分进程关联的都是根 uts_ns，在容器内的进程关联的是子 uts_ns。

在 gethostname 函数中，流程也差不多，先锁住信号量，然后用 utsname() 函数获取 current->nsproxy->uts_ns->name->nodename，然后复制到用户空间，

```c
SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)
{
	int i, errno;
	struct new_utsname *u;

	if (len < 0)
		return -EINVAL;
	down_read(&uts_sem);
	u = utsname();
	i = 1 + strlen(u->nodename);
	if (i > len)
		i = len;
	errno = 0;
	if (copy_to_user(name, u->nodename, i))
		errno = -EFAULT;
	up_read(&uts_sem);
	return errno;
}
```

# IPC（Interprocess Communication）namespace

在 create_new_namespaces() 函数的流程中，再看复制 ipc_namespace 的 copy_ipcs 函数：若编译参数 CONFIG_IPC_NS 未被定义过，则 clone 时遇到 CLONE_NEWIPC 参数直接报错；若编译参数 CONFIG_IPC_NS 被定义过，且检查到 CLONE_NEWIPC 参数，则会调用 create_ipc_ns 函数来创建一个新的 namespace，

```c
// include/linux/ipc_namespace.h

#if defined(CONFIG_IPC_NS)
extern struct ipc_namespace *copy_ipcs(unsigned long flags,
	struct user_namespace *user_ns, struct ipc_namespace *ns);

static inline struct ipc_namespace *get_ipc_ns(struct ipc_namespace *ns)
{
	if (ns)
		atomic_inc(&ns->count);
	return ns;
}

extern void put_ipc_ns(struct ipc_namespace *ns);
#else
// #if defined(CONFIG_IPC_NS) 条件不满足则在执行这个函数时直接返回父进程相应的 namespace
static inline struct ipc_namespace *copy_ipcs(unsigned long flags,
	struct user_namespace *user_ns, struct ipc_namespace *ns)
{
	if (flags & CLONE_NEWIPC)
		return ERR_PTR(-EINVAL);

	return ns;
}

static inline struct ipc_namespace *get_ipc_ns(struct ipc_namespace *ns)
{
	return ns;
}

static inline void put_ipc_ns(struct ipc_namespace *ns)
{
}
#endif


// ipc/namespace.c
// 若 #if defined(CONFIG_IPC_NS) 条件满足则允许创建新的 namespace，也即调用 create_ipc_ns 函数
struct ipc_namespace *copy_ipcs(unsigned long flags,
 struct user_namespace *user_ns, struct ipc_namespace *ns)
{
 if (!(flags & CLONE_NEWIPC))
   return get_ipc_ns(ns);
 return create_ipc_ns(user_ns, ns);
}
```

看这里创建新 namespace 的核心函数 create_ipc_ns，

```c
static struct ipc_namespace *create_ipc_ns(struct user_namespace *user_ns,
					   struct ipc_namespace *old_ns)
{
	struct ipc_namespace *ns;
	int err;

	ns = kmalloc(sizeof(struct ipc_namespace), GFP_KERNEL);	// 分配内存
	if (ns == NULL)
		return ERR_PTR(-ENOMEM);

	err = ns_alloc_inum(&ns->ns);
	if (err) {
		kfree(ns);
		return ERR_PTR(err);
	}
	ns->ns.ops = &ipcns_operations;

	atomic_set(&ns->count, 1);	// 设置计数值
	err = mq_init_ns(ns);
	if (err) {
		ns_free_inum(&ns->ns);
		kfree(ns);
		return ERR_PTR(err);
	}
	atomic_inc(&nr_ipc_ns);

	sem_init_ns(ns);	// 做初始化工作，具体在干嘛不清楚
	msg_init_ns(ns);
	shm_init_ns(ns);

	ns->user_ns = get_user_ns(user_ns);

	return ns;
}
```

# PID namespace

## copy_pid_ns() 函数

再看复制 pid_namespace 的 copy_pid_ns 函数，

```c
struct pid_namespace *copy_pid_ns(unsigned long flags,
	struct user_namespace *user_ns, struct pid_namespace *old_ns)
{
	if (!(flags & CLONE_NEWPID))	// 检查 flag
		return get_pid_ns(old_ns);
	if (task_active_pid_ns(current) != old_ns)	// 检查当前的 pid_namespace 和 old_ns 是否一致？
		return ERR_PTR(-EINVAL);
	return create_pid_namespace(user_ns, old_ns);	// 创建新的 pid_namespace
}
```

看 create_pid_namespace 函数，基本就是新建一个 struct pid_namespace 变量，然后设置它的各变量并返回的过程，

```c
static struct pid_namespace *create_pid_namespace(struct user_namespace *user_ns,
	struct pid_namespace *parent_pid_ns)
{
	struct pid_namespace *ns;
	unsigned int level = parent_pid_ns->level + 1;	// pid namespace 的套娃层数+1？
	int i;
	int err;

    // MAX_PID_NS_LEVEL 定义为32，说明 pid namespace 的套娃不能超过32层？
	if (level > MAX_PID_NS_LEVEL) {	
		err = -EINVAL;
		goto out;
	}

	err = -ENOMEM;
	ns = kmem_cache_zalloc(pid_ns_cachep, GFP_KERNEL);	// 申请内存？
	if (ns == NULL)
		goto out;

	ns->pidmap[0].page = kzalloc(PAGE_SIZE, GFP_KERNEL);
	if (!ns->pidmap[0].page)
		goto out_free;

	ns->pid_cachep = create_pid_cachep(level + 1);
	if (ns->pid_cachep == NULL)
		goto out_free_map;

	err = ns_alloc_inum(&ns->ns);
	if (err)
		goto out_free_map;
	ns->ns.ops = &pidns_operations;

	kref_init(&ns->kref);
	ns->level = level;
	ns->parent = get_pid_ns(parent_pid_ns);
	ns->user_ns = get_user_ns(user_ns);
	ns->nr_hashed = PIDNS_HASH_ADDING;
	INIT_WORK(&ns->proc_work, proc_cleanup_work);

	set_bit(0, ns->pidmap[0].page);
	atomic_set(&ns->pidmap[0].nr_free, BITS_PER_PAGE - 1);

	for (i = 1; i < PIDMAP_ENTRIES; i++)
		atomic_set(&ns->pidmap[i].nr_free, BITS_PER_PAGE);

	return ns;

out_free_map:
	kfree(ns->pidmap[0].page);
out_free:
	kmem_cache_free(pid_ns_cachep, ns);
out:
	return ERR_PTR(err);
}
```

## 重要结构

struct pid_namespace 的结构：

```c
struct pid_namespace {
	struct kref kref;	// 引用计数
	struct pidmap pidmap[PIDMAP_ENTRIES];	// pid 分配的 bitmap，为1表示已分配
	struct rcu_head rcu;
	int last_pid;		// 记录上次分配的 pid，默认当前分配的 pid=last_pid+1
	unsigned int nr_hashed;
	struct task_struct *child_reaper;
	struct kmem_cache *pid_cachep;	// 用于分配 pid 结构的 slab 缓存
	unsigned int level;	// 记录该 pidns 的深度
	struct pid_namespace *parent;	// 父 pidns
#ifdef CONFIG_PROC_FS
	struct vfsmount *proc_mnt;
	struct dentry *proc_self;
	struct dentry *proc_thread_self;
#endif
#ifdef CONFIG_BSD_PROCESS_ACCT
	struct fs_pin *bacct;
#endif
	struct user_namespace *user_ns;
	struct work_struct proc_work;
	kgid_t pid_gid;
	int hide_pid;
	int reboot;	/* group exit code if this pidns was rebooted */
	struct ns_common ns;
};
```

理解 pid 还需要再了解其他几个重要结构。

一个进程对应一个 task struct，但是这个进程在多个 pidns 中可以看到不同的 pid，对于这些 pid 的管理，主要通过两个结构体来实现。

```c
struct upid {	// 这个结构记录了某个进程在某个深度下的 pid 值和对应的 pid_namespace 结构
	/* Try to keep pid_chain in the same cacheline as nr for find_vpid */
	int nr;		// pid 的数值
	struct pid_namespace *ns;		// 所在命名空间
	struct hlist_node pid_chain;	// 链表节点
};

struct pid	// 这个结构和进程一一对应
{
	atomic_t count;
	unsigned int level;		// 这个 pid 结构体的深度
	/* lists of tasks that use this pid */
	struct hlist_head tasks[PIDTYPE_MAX];	// 使用这个pid的进程链表
	struct rcu_head rcu;
	struct upid numbers[1];	// 这个pid在不同命名空间中的显示；这里数组大小虽然为1，但其实可以在申请内存时调整
};
```

## 使用到这个 namespace 的相关函数

看一下在 getpid 函数中，进程获取 pid 时是怎么处理 pid namespace 的：

```c
SYSCALL_DEFINE0(getpid)
{
	return task_tgid_vnr(current);
}
```

```c
static inline pid_t task_tgid_vnr(struct task_struct *tsk)
{
    // 这里 task_tgid(tsk) 函数就是获得当前进程的 group leader（进程的 task_group 就是它自己，线程的 task_group 是它的父进程，调用 pthread_create 的那个进程）的 pid 结构
    // 但这里为啥是请求 group leader 的 pid 呢？
	return pid_vnr(task_tgid(tsk));
}
```

```c
pid_t pid_vnr(struct pid *pid)
{
	return pid_nr_ns(pid, task_active_pid_ns(current));
}
```

```c
pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)
{
	struct upid *upid;
	pid_t nr = 0;

	if (pid && ns->level <= pid->level) {
		upid = &pid->numbers[ns->level];	// 取出当前 pid 在特定深度下的 upid
		if (upid->ns == ns)	// 如果 upid 对应的 ns 和传入的 ns（current 的 ns）一致，就返回 nr（也即该深度下的 pid 值）；但什么时候这个条件会不成立呢？
			nr = upid->nr;
	}
	return nr;
}
```

# Mount namespaces

# Network namespace

# User namespaces

# 参考

[4.1.19版本的Linux内核源码](https://elixir.bootlin.com/linux/v4.1.19)

[Pid_namespace分析](https://blog.csdn.net/tanzhe2017/article/details/81003281)